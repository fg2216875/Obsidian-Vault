### 索引說明
#### 索引 (index)
- 目的: SQL索引是資料庫的關鍵元素之一，主要目的為加速查詢速度
- 組成方式:索引通常包含一個或多個欄位，一張 table 有索引時，資料就會依照索引的鍵值排序及儲存，以便更迅速地檢索。
- 有兩種主要類型：叢集索引(clustered-index)和非叢集索引(non-clustered-index)，通常使用 B-Tree 結構構建，若沒有索引的就是堆積(Heap)
#### 叢集索引 (Clustered Index）
- 當資料表設定了「叢集索引」，那麼該資料表中的「實體資料列」的順序就會依據叢集索引鍵的值做排列，所以資料表中就只能有一個「叢集索引」。 
- 在 SQL Server ，當資料表有建立PRIMARY KEY(PK)時,會自動建立「叢集索引」並且是唯一的（Unique），不一定要使用 PK 來當「叢集索引」。
- 若要將別的索引設定為叢集索引，則必須先取消主索鍵的叢集(Clustered)屬性。

![[Pasted image 20241126180235.png]]

#### 非叢集索引（NonClustered Index）
- 一個資料表可以有多組
- 資料表有主鍵時，索引指向主鍵的索引。
- 如果資料表中沒有設主鍵，則指到資料頁的物理位置，也就是 Heaper 內實體資料所存放的位置(`RID`)。

假如`NonClustered Index`沒有包含到所要查詢欄位時
```sql
select name,moblie from Members 
where name = 'Andy'  --假設name欄位是NonClustered Index
```
1. table有`Clustered Index`，會執行`索引鍵查閱(Key Lookup)`
2. table沒有`Clustered Index`，會執行`RID查閱(RID Lookup)`

---
### 建立索引的優點
#### 1. **提升查詢效能**
- 索引使 SQL Server 能更快速地定位資料，減少表掃描的次數。
- 尤其對於大型資料表中的查詢，索引的效能提升尤為明顯。

#### 2. **加速排序和分組操作**
- 索引有助於加快 `ORDER BY`、`GROUP BY` 和聚合函數（如 `SUM`、`COUNT`）的計算速度。

#### 3. **提高 JOIN 操作效能**
- 若在 JOIN 條件中涉及的欄位建立了索引，可以顯著減少資料庫的比較和匹配操作。

### **建立索引的缺點**
#### 1. **增加儲存空間需求**
- 每個索引需要額外的磁碟空間來存儲索引結構，特別是對於大表格上的多個索引，儲存成本會顯著增加。

#### 2. **降低資料操作效能**
- **新增**：每次新增新資料時，必須更新所有受影響的索引。
- **更新**：更新索引鍵時，索引會重新排序，增加成本。
- **刪除**：刪除資料時也需同步更新索引。

#### 3. **增加維護成本**
- 索引會隨時間產生碎片（Fragmentation），需要定期重組（Reorganize）或重建（Rebuild），特別是頻繁更新的表。
    - **碎片的影響**：降低讀取效能，增加查詢時間。

#### 4. **可能導致查詢計劃選擇不當**
- 在建立了多個索引後，SQL Server 的查詢優化器可能選擇次佳索引，導致效能不如預期。

---
### 適合建立叢集索引的欄位
#### 1.**常用於篩選的欄位**（WHERE 或 JOIN 條件）：
- 如果某欄位經常出現在查詢的篩選條件`WHERE`或`JOIN`條件中(foreign Key 欄位)，適合建立索引。

#### 2.**排序欄位**（ORDER BY 或 GROUP BY）：
- 如果欄位經常用於排序或分組，可以考慮索引。

#### 3.連續性的範圍查詢(BETWEEN):
- 若依 Between `>=` `<=` 等符號查詢時，當系統找到第一筆資料後，依序逐筆往下讀取，查詢的結果是連續性的範圍，則執行的速度也會提升。

#### 4.唯一性高（Unique Key）


### 不適合當叢集索引的欄位
#### 1. 更新頻率過高的欄位  
- 因為Clustered Index每次更新時都會對實體資料進行排序，如果資料量較大的資料表，系統會在排序上會多花不少時間處理。

#### 2.過多或過大的欄位所組成鍵值
- 不適合在大容量欄位（如 `VARCHAR(MAX)` 或 `VARBINARY(MAX)`）上建立索引。

#### 3.**小型表格**：
- 資料量少的小型table，索引效益不明顯，掃描表格可能更有效。

---
### Scan (掃描) 
Scan 是指查詢執行時，系統會以整個資料表或整個索引的方式讀取資料，一筆筆去找出資料。

### Index Seek (搜尋) 
Seek 是指在一個使用 B-Tree 排序過的實體資料中尋找資料。 所以會使用 Seek 必定該資料建有**Index(索引)** 的情況下才有可能，

既使建了索引，資料庫也不見得會使用索引，得看查詢條件是否有正確使用索引，這與**查詢參數**有相當大的關連。

在查詢參數足夠**選擇性**（Selectivity）時，才會正確使用到索引。 選擇性是指合格資料列與總資料列的比率。 如果比率低，表示索引具有高度選擇性。
這項索引就可以排除大部分的資料列，並大幅減少結果集的大小。

---
### 資料表掃描（table scan）
這種搜尋方式，是當一個資料表沒有建立任何 Index 時所採取的資料搜尋方式，也就是實體資料以 Heap 架構存放時的處理方式

### 叢集索引掃描（clustered index scan）
當一個資料表雖有建立叢集索引，但是查詢的 WHERE 條件中卻沒有使用到實體資料排序， 這時的搜尋方式，就會掃過整個叢集索引，以找出符合的資料。

### 叢集索引搜尋（clustered index seek）
SQL Server 使用查詢參數中的第一個值，在**叢集索引**進行搜尋。 這種方式是最有效率的搜尋方式，資料完全利用叢集索引內所建立的實體資料排序。

假設`tbUser`資料表的索引為`UserID`
```sql
SELECT UserID FROM tbUser WHERE UserID=@UserID AND Password=@Password
SELECT UserID FROM tblUser WHERE UserID=@UserID
```
上述的指令都會採用**叢集索引搜尋**，雖然 Password 不是索引欄位，但是查詢條件中已包含了 UserID 這個索引欄位，所以整體會使用**叢集索引搜尋**。

```sql
SELECT UserID FROM tblUser WHERE Password=@Password
```
此指令採用**叢集索引掃描** ，只要沒有透過索引搜尋，當遇到資料量大的資料表時，效率就會降的非常快，因為它必須掃過所有的資料才能找到想要的資料。

### 索引掃描（index scan）
掃描整個**非叢集索引**。

參考:
[效能調校(2)-分析執行計畫](https://vito-note.blogspot.com/2013/05/blog-post_2862.html)
[建立索引(1)-叢集與非叢集索引](https://vito-note.blogspot.com/2013/05/blog-post_5510.html)
[效能調校(3)-讓索引變的有用](https://vito-note.blogspot.com/2014/03/3.html)
[【SQL Server】索引筆記](https://clarklin.gitlab.io/2020/12/13/sql-server-index-note/)