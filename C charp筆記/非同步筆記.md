### 非同步(Asynchronous)不在於提高效能(Performance)，而是增加產能(Throughput)

非同步追求的是在相同時間內處理更多請求，而非以更快的速度處理掉一個請求。總體來看，同樣的請求量在更短時間內做完，說成「效能變好」也不算錯，但要記住，非同步的核心精神在於減少等待，讓執行緒同時處理更多作業藉以提升產能。

### 非同步不等於多執行緒

多緒執行的精神在於建立多條執行緒，將多個工作交給不同執行緒個別處理，靠分工加速；而非同步的重點則是允許執行緒在等待時間先處理其他作業(Task，也可翻譯為工作，個人偏好作業，以與 Work 區隔)，透過消除閒置增加產能。

.NET 實現非同步作業的做法是在需要等待時建立 SynchronizationContext，讓執行緒中斷作業先去處理其他作業，等待結束後再回頭繼續後半段。而繼續執行作業的執行緒可以是當初建立 SynchronizationContext 的那一條執行緒，也可以是其他執行緒。

### 非同步只對 I/O 相關作業有效，對吃 CPU 的作業沒轍

由前面的說明，我們知道非同步提升產能的關鍵在於善用等待時間先處理其他作業。當作業涉及大量消耗 CPU 的重度運算 ，代表執行緒將從頭忙到尾，既然不會閒下來等待，也就不可能分神再處理其他作業。 相反的，若作業涉及外部資源或與 I/O 相關，例如：存取資料庫、呼叫 Web API，等待回應的期間即可透過非同步讓執行緒先處理其他作業。

換言之，若是一堆吃 CPU 的作業，增加執行緒肯定可以加速；若為要等待 I/O 回應的作業，增加執行緒用處不大，改為非同步作業才算對症下藥。

### async 像病毒一樣會傳染

這是開始寫 async/await 肯定非常有感的一件事 - **async 具有傳染性**，一旦你在方法前面加上 async 關鍵字，不得了， 裡面呼叫外部方法必須加上 await 才合規格，而要加 await 該外部方法順理成章也得加上 async，接著外部方法中又被要求使用 await... 像病毒般一路蔓延。 此一設計的理由是為了避免同步與非同步寫法混用以防止在 GUI/ASP.NET 情境產生 Deadlock。(註：作者的[第二篇文章](https://exceptionnotfound.net/asynchronous-programming-asp-net-csharp-practical-guide-refactoring/)有 Deadlock 實例，或者也可參考我的舊文 [await與Task.Result/Task.Wait()的Deadlock問題](https://blog.darkthread.net/blog/await-task-block-deadlock/))

### 回傳型別

宣告為 async 的 .NET 方法必須傳回以下三種型別之一：

1.  Task  
    作業結束時將控制權還給呼叫端
2.  Task<T>  
    作業結束時回傳型別為 T 的物件給呼叫端
3.  void  
    採射後不理(Fire-and-Forget)哲學，呼叫後即失去掌握  
    async void 在實務上不應使用，事件處理器是唯一例外

### 如何將同步程式重構為非同步

因為 async 像病毒會傳染，如要將同步寫法程式重構為非同步，建議採「由下而上」(Bottom-Up)策略。

參考:https://blog.darkthread.net/blog/async-aspnet/
==========================================================
**Task.WaitAll**
在非同步情境時使用 WaitAll 會阻礙執行緒或鎖定 ( blocks thread )，會造成在所有的工作結束之前，當前使用到的執行緒無法自由處理其他工作，在此篇 [How and Where Concurrent Asynchronous I/O with ASP.NET Web API](http://www.tugberkugurlu.com/archive/how-and-where-concurrent-asynchronous-io-with-asp-net-web-api) 文章有提到，如果某項任務無法正確執行最後引起 deadlocks 狀況發生，此時需要使用 ConfigureAwait 來避免執行緒 lock，更詳細的內容可以參考 [Best Practices in Asynchronous Programming](https://msdn.microsoft.com/en-us/magazine/jj991977.aspx?f=255&MSPPError=-2147217396)。

======================================================
**Task.WhenAll**  
另一個等待所有任務完成的方法是 Task.WhenAll，使用的 Sample Code 中是相同於上述代碼，使用方式不難，在 [MSDN](https://www.blogger.com/goog_441382394) [Task.Whenall](https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.tasks.task.whenall?view=netframework-4.7.2) 方法簽章可以看到，使用 Task.WhenAll 方法時會回傳 Task，因此與剛剛差異的是其中等待完成任務方法使用 WhenAll 進行，在使用一個 taskWhenAll 變數用 wait 方法等待完成

====================================================
**Task.WaitAll v.s Task.WhenAll**
為了避免執行緒阻塞的情形發生，使用上建議 **Task.WhenAll 來取代 Task.WaitAll**，從最後的簡單測試代碼執行時間比較來看也是 WhenAll 會優於 WaitAll